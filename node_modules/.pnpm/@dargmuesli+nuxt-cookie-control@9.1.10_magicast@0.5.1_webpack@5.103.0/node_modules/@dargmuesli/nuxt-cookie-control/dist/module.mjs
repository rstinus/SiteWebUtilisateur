import { resolve } from 'node:path';
import { pathToFileURL } from 'node:url';
import { createResolver, defineNuxtModule, addPlugin, addImports, addTypeTemplate, updateTemplates, extendWebpackConfig, extendViteConfig, resolvePath } from '@nuxt/kit';
import { defu } from 'defu';
import en from '../dist/runtime/locale/en.js';

const CONFIG_KEY = "cookieControl";

const execSrcReplacements = (src, replacements) => {
  for (const replacement of replacements) {
    if ((typeof replacement.from === "string" || replacement.from instanceof RegExp) === false) {
      throw new TypeError(
        "[vite-plugin-replace]: The replacement option 'from' is not of type 'string' or 'RegExp'."
      );
    } else if ((typeof replacement.to === "string" || replacement.to instanceof Function) === false) {
      throw new TypeError(
        "[vite-plugin-replace]: The replacement option 'to' is not of type 'string' or 'Function'"
      );
    } else src = src.replace(replacement.from, replacement.to);
  }
  return src;
};
const replaceCodePlugin = (config) => {
  if (config === void 0) {
    config = {
      replacements: []
    };
  } else if ((typeof config === "object" || config !== null) === false) {
    throw new TypeError(
      "[vite-plugin-replace]: The configuration is not of type 'Object'."
    );
  } else if (Array.isArray(config.replacements) === false) {
    throw new TypeError(
      "[vite-plugin-replace]: The configuration option 'replacement' is not of type 'Array'."
    );
  }
  return {
    name: "transform-file",
    enforce: "pre",
    transform: function(src) {
      return {
        code: execSrcReplacements(src, config.replacements),
        map: null
      };
    }
  };
};

const DEFAULTS = {
  _isPrerendered: void 0,
  barPosition: "bottom-full",
  closeModalOnClickOutside: false,
  colors: {
    barBackground: "#000",
    barButtonBackground: "#fff",
    barButtonColor: "#000",
    barButtonHoverBackground: "#333",
    barButtonHoverColor: "#fff",
    barTextColor: "#fff",
    checkboxActiveBackground: "#000",
    checkboxActiveCircleBackground: "#fff",
    checkboxDisabledBackground: "#ddd",
    checkboxDisabledCircleBackground: "#fff",
    checkboxInactiveBackground: "#000",
    checkboxInactiveCircleBackground: "#fff",
    controlButtonBackground: "#fff",
    controlButtonHoverBackground: "#000",
    controlButtonIconColor: "#000",
    controlButtonIconHoverColor: "#fff",
    focusRingColor: "#808080",
    modalBackground: "#fff",
    modalButtonBackground: "#000",
    modalButtonColor: "#fff",
    modalButtonHoverBackground: "#333",
    modalButtonHoverColor: "#fff",
    modalOverlay: "#000",
    modalOverlayOpacity: 0.8,
    modalTextColor: "#000",
    modalUnsavedColor: "#fff"
  },
  cookies: {
    necessary: [],
    optional: []
  },
  cookieExpiryOffsetMs: 1e3 * 60 * 60 * 24 * 365,
  // one year
  cookieNameIsConsentGiven: "ncc_c",
  cookieNameCookiesEnabledIds: "ncc_e",
  cookieOptions: {
    path: "/",
    sameSite: "strict",
    secure: process.env.NODE_ENV === "development" ? void 0 : true
  },
  isAcceptNecessaryButtonEnabled: true,
  isControlButtonEnabled: true,
  isCookieIdVisible: false,
  isCssEnabled: true,
  isCssPonyfillEnabled: false,
  isDashInDescriptionEnabled: true,
  isIframeBlocked: false,
  isModalForced: false,
  declineAllAcceptsNecessary: false,
  locales: ["en"],
  localeTexts: { en }
};

const name = "@dargmuesli/nuxt-cookie-control";
const version = "9.1.10";

const resolver = createResolver(import.meta.url);
const runtimeDir = resolver.resolve("./runtime");
const module$1 = defineNuxtModule({
  meta: {
    name,
    version,
    configKey: CONFIG_KEY,
    compatibility: { nuxt: ">=3.0.0" }
  },
  defaults: DEFAULTS,
  hooks: {
    "components:dirs"(dirs) {
      dirs.push({
        path: resolver.resolve(runtimeDir, "components"),
        prefix: "cookie"
      });
    }
  },
  async setup(moduleOptions, nuxt) {
    moduleOptions._isPrerendered = nuxt.options.nitro.static || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    nuxt.options._generate;
    nuxt.options.alias["#cookie-control/set-vars"] = moduleOptions.isCssPonyfillEnabled ? resolver.resolve(runtimeDir, "set-vars/ponyfill") : resolver.resolve(runtimeDir, "set-vars/native");
    nuxt.options.alias["#cookie-control"] = runtimeDir;
    nuxt.options.build.transpile.push("#cookie-control");
    pushCss(moduleOptions, nuxt);
    blockIframes(moduleOptions);
    await loadLocales(moduleOptions);
    addPlugin(resolver.resolve(runtimeDir, "plugin"));
    addImports({
      name: "useCookieControl",
      as: "useCookieControl",
      from: resolver.resolve(runtimeDir, "composables")
    });
    addTypeTemplate({
      filename: "types/cookie-control.d.ts",
      getContents: getTypeTemplate,
      options: moduleOptions
    });
    nuxt.hook("builder:watch", async (_event, path) => {
      if (path.includes(`${CONFIG_KEY}.cookies`)) {
        updateTemplates({
          filter: (t) => t.filename === "types/cookie-control.d.ts"
        });
      }
    });
    nuxt.hook("modules:done", async () => {
      nuxt.options.runtimeConfig.public.cookieControl = defu(
        nuxt.options.runtimeConfig.public.cookieControl,
        moduleOptions
      );
    });
  }
});
const blockIframes = (moduleOptions) => {
  if (moduleOptions.isIframeBlocked) {
    const isIframeBlocked = {
      id: "ncc_f",
      name: "functional"
    };
    if (moduleOptions.cookies) {
      if (moduleOptions.cookies.optional) {
        moduleOptions.cookies.optional.push(isIframeBlocked);
      } else {
        moduleOptions.cookies.optional = [isIframeBlocked];
      }
    }
    extendWebpackConfig((config) => {
      config.module?.rules?.push({
        test: /\.vue$/,
        loader: "string-replace-loader",
        exclude: /node_modules/,
        options: {
          multiple: [
            { search: "<iframe", replace: "<CookieIframe", flags: "g" },
            { search: "</iframe>", replace: "</CookieIframe>", flags: "g" }
          ]
        }
      });
    });
    extendViteConfig((config) => {
      config?.plugins?.push(
        replaceCodePlugin({
          replacements: [
            {
              from: /<iframe[^>]*.*|<\/iframe>/g,
              to: (match) => match.includes("cookie-enabled") ? match : match.replace(/<iframe/g, "<CookieIframe").replace(/iframe>/g, "CookieIframe>")
            }
          ]
        })
      );
    });
  }
};
const getTypeTemplate = (data) => `// Generated by ${name}

/**
* Union of the cookie ids specified in the Nuxt configuration.
*/
export type CookieID = ${Object.values([
  ...data.options.cookies.necessary,
  ...data.options.cookies.optional
]).map((cookie) => `"${cookie.id}"`).join(" | ") || "never"}

export type CookieIDs = Array<CookieID>
`;
const loadLocales = async (moduleOptions) => {
  const locales = moduleOptions.locales;
  moduleOptions.locales = [];
  for (const locale of locales) {
    const text = await import(pathToFileURL(await resolvePath(resolve(runtimeDir, "locale", locale))).href).then((r) => r.default || r);
    if (!text) throw new Error(`Could not import text for locale ${locale}`);
    moduleOptions.locales.push(locale);
    moduleOptions.localeTexts[locale] = {
      ...text,
      ...moduleOptions.localeTexts[locale]
    };
  }
};
const pushCss = (moduleOptions, nuxt) => {
  if (moduleOptions.isCssEnabled)
    nuxt.options.css.push(resolver.resolve(runtimeDir, "styles.css"));
};

export { module$1 as default };
